<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Reverse engineering UML osztálydiagram</title>
        <para>
          UML osztálydiagram rajzolása az első védési C++ programhoz. Az osztálydiagramot a forrásokból
generáljuk (pl. Argo UML, Umbrello, Eclipse UML) Mutassunk rá a kompozíció és aggregáció
kapcsolatára a forráskódban és a diagramon, lásd még: https://youtu.be/Td_nlERlEOs.
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_6.pdf (28-32 fólia)
        </para>
        <para>
          Az Umbrello programot választottam, mivel ingyenes és tökéletesen megfelel a feladat igényeinek. Magunktól is elkészíthetnénk az osztálydiagramot, de minek húznánk ezzel az időt, ha a program meg tudja csináni helyettünk. Nézzük hogyan: A <function>Code</function> menüpont alatt a <function>Code Importing Wizard</function> opcióra kattintva megjelenik számunkra egy ablak, ahol kiválsztjuk az importálandó forráskód nyelvét, odanavigálunk és kiválasztjuk a forrásfájlt.
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/umb_step1.png" scale="75"/>
            </imageobject>
        </mediaobject>
        <para>
          A következő oldalon rá kell mennünk a <function>Start import</function> gombra és kész is vagyunk az importálással. Mostmár a <function>Tree view</function>-ban megjelent az osztályunk és azt egy sima behúzással megjeleníthetjük, de ne felejtsük el a <function>Csomopont</function> osztályt is behúzni.
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/umb_step2-3.png" scale="50"/>
            </imageobject>
        </mediaobject>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/umb_step4.png" scale="75"/>
            </imageobject>
        </mediaobject>
        <para>
          A végeredmény:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/binfa_uml.png" scale="10"/>
            </imageobject>
        </mediaobject>
        <para>
          A fejléc tartalmazza az osztály nevét, alatta vannak a mezők és úgy a metódusok.
          Amint azt láthatjuk, a <function>Csomopont</function> kompozícióban van az <function>LZWBinFa</function>-val, mivel ha kitörölnénk egy <function>LZWBinFa</function> objektumot, akkor a hozzá tartozó <function>Csomopont</function> objektum is törlődne. Aggregáció esetén ez nem lenne igaz.
        </para>


    </section>

    <section>
        <title>Forward engineering UML osztálydiagram</title>
        <para>
          UML-ben tervezzünk osztályokat és generáljunk belőle forrást!
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="mandelbrot2/forward_uml/LZWBinFa.cpp">
            <filename>bhax/thematic_tutorials/bhax_textbook/mandelbrot2/forward_uml/LZWBinFa.cpp</filename>
            </link>
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="mandelbrot2/forward_uml/LZWBinFa.h">
            <filename>bhax/thematic_tutorials/bhax_textbook/mandelbrot2/forward_uml/LZWBinFa.h</filename>
            </link>
        </para>
        <para>
          Most megpróbálunk az előző feladat uml diagramából generálni c++ kódot. Az Umbrello programban a <function>Code</function> menüpont alatt a <function>Code Generating Wizard</function> opcióval megnyílik egy ablak, ahol megadhatjuk a generálandó kód helyét, nyelvét és egyéb formázási beállításokat (pl. akarjuk-e hogy kiegészítse a kódot a kommentjeinkkel vagy sem) hajthatunk végre. Ezután kiválasztjuk legenerálni kívánt osztályokat és egy-két kattintással kész is a forráskód.
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/uml_code_gen.png" scale="50"/>
            </imageobject>
        </mediaobject>
        <para>
          A végeredmény egy .cpp és egy .h fájl. A header tartalmazza a mezőket és metódusokat, ám azok üresek, mivel a diagram csupán a metódus nevét, láthatóságát és argumentumait tartalmazza. Ezeken kívül létrehozott get/set metódusokat is a mezők lekérdezéséhez és módosításához.
        </para>
        <programlisting language="c"><![CDATA[#ifndef LZWBINFA_H
        #define LZWBINFA_H

        #include string

        /**
          * class LZWBinFa
          * osztályon belűl csak prototípusok legyenek,<<operátor kiiktatása,szeggyük külön
          * a programot 3 részre
          */

        class LZWBinFa
        {
        public:

         // Constructors/Destructors
         //

         /**
          * Empty Constructor
          */
         LZWBinFa ();

         /**
          * Empty Destructor
          */
         virtual ~LZWBinFa ();

         // Static Public attributes
         //

         // Public attributes
         //

         // Public attribute accessor methods
         //

         // Public attribute accessor methods
         //

         /**
          * @param  b
          */
         void operator_ (char b)
         {
         }

         /**
          */
         void kiir ()
         {
         }

         /**
          * A változatosság kedvéért ezeket az osztálydefiníció (class LZWBinFa {...};) után
          * definiáljuk,
          * hogy kénytelen légy az LZWBinFa és a :: hatókör operátorral minősítve definiálni
          * :) l. lentebb
          * @return int
          */
         int getMelyseg ()
         {
         }

         /**
          * @return double
          */
         double getAtlag ()
         {
         }

         /**
          * @return double
          */
         double getSzoras ()
         {
         }

         /**
          * @return std::ostream&
          * @param  os
          * @param  bf
          */
         std::ostream& operator_ (std::ostream& os, LZWBinFa& bf)
         {
         }

         /**
          * @param  os
          */
         void kiir (std::ostream& os)
         {
         }

         /**
          */
         void ki ()
         {
         }

         /**
          * @param  elem
          */
         void szabadit (Csomopont* elem)
         {
         }

        protected:

         // Static Protected attributes
         //

         // Protected attributes
         //

         // A fában tagként benne van egy csomópont, ez erősen ki van tüntetve, Ő a gyökér:
         Csomopont* gyoker;
         int maxMelyseg;
         double atlag;
         double szoras;
        public:

         // Protected attribute accessor methods
         //

        protected:

        public:

         // Protected attribute accessor methods
         //

         /**
          * Set the value of gyoker
          * A fában tagként benne van egy csomópont, ez erősen ki van tüntetve, Ő a gyökér:
          * @param new_var the new value of gyoker
          */
         void setGyoker (Csomopont* new_var)  {
           gyoker = new_var;
         }

         /**
          * Get the value of gyoker
          * A fában tagként benne van egy csomópont, ez erősen ki van tüntetve, Ő a gyökér:
          * @return the value of gyoker
          */
         Csomopont* getGyoker ()  {
          return gyoker;
         }

         /**
          * Set the value of maxMelyseg
          * @param new_var the new value of maxMelyseg
          */
         void setMaxMelyseg (int new_var)  {
           maxMelyseg = new_var;
         }

         /**
          * Get the value of maxMelyseg
          * @return the value of maxMelyseg
          */
         int getMaxMelyseg ()  {
          return maxMelyseg;
         }

         /**
          * Set the value of atlag
          * @param new_var the new value of atlag
          */
         void setAtlag (double new_var)  {
           atlag = new_var;
         }

         /**
          * Get the value of atlag
          * @return the value of atlag
          */
         double getAtlag ()  {
          return atlag;
         }

         /**
          * Set the value of szoras
          * @param new_var the new value of szoras
          */
         void setSzoras (double new_var)  {
           szoras = new_var;
         }

         /**
          * Get the value of szoras
          * @return the value of szoras
          */
         double getSzoras ()  {
          return szoras;
         }
        protected:

         /**
          * @param  elem
          */
         void rmelyseg (Csomopont* elem)
         {
         }

         /**
          * @param  elem
          */
         void ratlag (Csomopont* elem)
         {
         }

         /**
          * @param  elem
          */
         void rszoras (Csomopont* elem)
         {
         }

        private:

         // Static Private attributes
         //

         // Private attributes
         //

         // van nulla
         int vann;
         // nincs nulla
         int nincsn;
         // van egy
         int vane;
         // nincs egy
         int nincse;
         // Mindig a fa "LZW algoritmus logikája szerinti aktuális" csomópontjára mutat
         Csomopont* fa;
         // technikai
         int melyseg;
         int atlagosszeg;
         int atlagdb;
         double szorasosszeg;
        public:

         // Private attribute accessor methods
         //

        private:

        public:

         // Private attribute accessor methods
         //

         /**
          * Set the value of vann
          * van nulla
          * @param new_var the new value of vann
          */
         void setVann (int new_var)  {
           vann = new_var;
         }

         /**
          * Get the value of vann
          * van nulla
          * @return the value of vann
          */
         int getVann ()  {
          return vann;
         }

         /**
          * Set the value of nincsn
          * nincs nulla
          * @param new_var the new value of nincsn
          */
         void setNincsn (int new_var)  {
           nincsn = new_var;
         }

         /**
          * Get the value of nincsn
          * nincs nulla
          * @return the value of nincsn
          */
         int getNincsn ()  {
          return nincsn;
         }

         /**
          * Set the value of vane
          * van egy
          * @param new_var the new value of vane
          */
         void setVane (int new_var)  {
           vane = new_var;
         }

         /**
          * Get the value of vane
          * van egy
          * @return the value of vane
          */
         int getVane ()  {
          return vane;
         }

         /**
          * Set the value of nincse
          * nincs egy
          * @param new_var the new value of nincse
          */
         void setNincse (int new_var)  {
           nincse = new_var;
         }

         /**
          * Get the value of nincse
          * nincs egy
          * @return the value of nincse
          */
         int getNincse ()  {
          return nincse;
         }

         /**
          * Set the value of fa
          * Mindig a fa "LZW algoritmus logikája szerinti aktuális" csomópontjára mutat
          * @param new_var the new value of fa
          */
         void setFa (Csomopont* new_var)  {
           fa = new_var;
         }

         /**
          * Get the value of fa
          * Mindig a fa "LZW algoritmus logikája szerinti aktuális" csomópontjára mutat
          * @return the value of fa
          */
         Csomopont* getFa ()  {
          return fa;
         }

         /**
          * Set the value of melyseg
          * technikai
          * @param new_var the new value of melyseg
          */
         void setMelyseg (int new_var)  {
           melyseg = new_var;
         }

         /**
          * Get the value of melyseg
          * technikai
          * @return the value of melyseg
          */
         int getMelyseg ()  {
          return melyseg;
         }

         /**
          * Set the value of atlagosszeg
          * @param new_var the new value of atlagosszeg
          */
         void setAtlagosszeg (int new_var)  {
           atlagosszeg = new_var;
         }

         /**
          * Get the value of atlagosszeg
          * @return the value of atlagosszeg
          */
         int getAtlagosszeg ()  {
          return atlagosszeg;
         }

         /**
          * Set the value of atlagdb
          * @param new_var the new value of atlagdb
          */
         void setAtlagdb (int new_var)  {
           atlagdb = new_var;
         }

         /**
          * Get the value of atlagdb
          * @return the value of atlagdb
          */
         int getAtlagdb ()  {
          return atlagdb;
         }

         /**
          * Set the value of szorasosszeg
          * @param new_var the new value of szorasosszeg
          */
         void setSzorasosszeg (double new_var)  {
           szorasosszeg = new_var;
         }

         /**
          * Get the value of szorasosszeg
          * @return the value of szorasosszeg
          */
         double getSzorasosszeg ()  {
          return szorasosszeg;
         }
        private:

         /**
          * @param
          */
          LZWBinFa (const LZWBinFa& )
         {
         }

         /**
          * szokásosan: nocopyable
          * @return LZWBinFa&
          * @param
          */
         LZWBinFa& operator_ (const LZWBinFa& )
         {
         }

         /**
          * @param  elem
          * @param  os
          */
         void kiir (Csomopont* elem, std::ostream& os)
         {
         }

         void initAttributes () ;

        };

        #endif // LZWBINFA_H
]]>
        </programlisting>

    </section>

    <section>
        <title>Egy esettan</title>
        <para>
          A BME-s C++ tankönyv 14. fejezetét (427-444 elmélet, 445-469 az esettan) dolgozzuk fel!
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="mandelbort2/esettan/PiBBPBench.java">
            <filename>bhax/thematic_tutorials/bhax_textbook/liskov/antioo/PiBBPBench.java</filename>
            </link>
        </para>
        <para>

        </para>
        <programlisting language="c"><![CDATA[
]]>
        </programlisting>





    </section>

    <section>
        <title>BPMN</title>
        <para>
          Rajzoljunk le egy tevékenységet BPMN-ben!
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_7.pdf (34-47 fólia)
        </para>
        <para>
          A BPMN széles körben használt és elfogadott módja a folyamatok ábrázolásának. Ilyen ábrák készítéséhez a következő eszközök állnak a rendelkezésünkre:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/bpmn_tut.png" scale="75"/>
            </imageobject>
        </mediaobject>
        <para>
          Példa: panaszlevelet küld egy vásárló. A support részleg elküldi válaszát a vásárlónak és vár a visszajelzésre. Ha a vásárló 2 napig nem válaszol, akkor nem foglalkoznak vele többet. Ha viszont válaszol, de válaszában további elégedetlenségét nyilvánítja ki, akkor az ide-oda levelezés tovább folytatódik amíg a vásárló elégedett nem lesz és így le nem zárul az ügy.
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/bpmn.png" scale="75"/>
            </imageobject>
        </mediaobject>



    </section>

    <section>
        <title>TeX UML</title>
        <para>
          Valamilyen TeX-es csomag felhasználásával készíts szép diagramokat az OOCWC projektről (pl.
  use case és class diagramokat).
        </para>
        <para>
            Megoldás forrása:

        </para>

        <para>

        </para>


    </section>


</chapter>
