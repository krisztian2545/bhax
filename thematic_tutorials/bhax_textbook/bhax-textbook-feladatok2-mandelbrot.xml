<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Reverse engineering UML osztálydiagram</title>
        <para>
          UML osztálydiagram rajzolása az első védési C++ programhoz. Az osztálydiagramot a forrásokból
generáljuk (pl. Argo UML, Umbrello, Eclipse UML) Mutassunk rá a kompozíció és aggregáció
kapcsolatára a forráskódban és a diagramon, lásd még: https://youtu.be/Td_nlERlEOs.
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_6.pdf (28-32 fólia)
        </para>
        <para>
          Az Umbrello programot választottam, mivel ingyenes és tökéletesen megfelel a feladat igényeinek. Magunktól is elkészíthetnénk az osztálydiagramot, de minek húznánk ezzel az időt, ha a program meg tudja csináni helyettünk. Nézzük hogyan: A <function>Code</function> menüpont alatt a <function>Code Importing Wizard</function> opcióra kattintva megjelenik számunkra egy ablak, ahol kiválsztjuk az importálandó forráskód nyelvét, odanavigálunk és kiválasztjuk a forrásfájlt.
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/umb_step1.png" scale="75"/>
            </imageobject>
        </mediaobject>
        <para>
          A következő oldalon rá kell mennünk a <function>Start import</function> gombra és kész is vagyunk az importálással. Mostmár a <function>Tree view</function>-ban megjelent az osztályunk és azt egy sima behúzással megjeleníthetjük, de ne felejtsük el a <function>Csomopont</function> osztályt is behúzni.
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/umb_step2-3.png" scale="50"/>
            </imageobject>
        </mediaobject>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/umb_step4.png" scale="75"/>
            </imageobject>
        </mediaobject>
        <para>
          A végeredmény:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/binfa_uml.png" scale="10"/>
            </imageobject>
        </mediaobject>
        <para>
          A fejléc tartalmazza az osztály nevét, alatta vannak a mezők és úgy a metódusok.
          Amint azt láthatjuk, a <function>Csomopont</function> kompozícióban van az <function>LZWBinFa</function>-val, mivel ha kitörölnénk egy <function>LZWBinFa</function> objektumot, akkor a hozzá tartozó <function>Csomopont</function> objektum is törlődne. Aggregáció esetén ez nem lenne igaz.
        </para>

        <para>
          A forráskódban ez úgy jelenik meg, hogy a <function>Csomopont</function> osztály az <function>LZWBinFa</function>-n belül van deklarálva és ezért a destruktorban felszabadítjuk.
        </para>
        <programlisting><![CDATA[
          class LZWBinFa
          {
          public:

              LZWBinFa ():fa (gyoker = new Csomopont('/'))
              {
              }
              ~LZWBinFa ()
              {
                  szabadit (gyoker->egyesGyermek ());
                  szabadit (gyoker->nullasGyermek ());
              delete gyoker;
              }
              ...
          private:
              class Csomopont
              {
                  ...
              };
              ...
          };
          ]]>
        </programlisting>



    </section>

    <section>
        <title>Forward engineering UML osztálydiagram</title>
        <para>
          UML-ben tervezzünk osztályokat és generáljunk belőle forrást!
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="mandelbrot2/forward_uml/LZWBinFa.cpp">
            <filename>bhax/thematic_tutorials/bhax_textbook/mandelbrot2/forward_uml/LZWBinFa.cpp</filename>
            </link>
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="mandelbrot2/forward_uml/LZWBinFa.h">
            <filename>bhax/thematic_tutorials/bhax_textbook/mandelbrot2/forward_uml/LZWBinFa.h</filename>
            </link>
        </para>
        <para>
          Most megpróbálunk az előző feladat uml diagramából generálni c++ kódot. Az Umbrello programban a <function>Code</function> menüpont alatt a <function>Code Generating Wizard</function> opcióval megnyílik egy ablak, ahol megadhatjuk a generálandó kód helyét, nyelvét és egyéb formázási beállításokat (pl. akarjuk-e hogy kiegészítse a kódot a kommentjeinkkel vagy sem) hajthatunk végre. Ezután kiválasztjuk legenerálni kívánt osztályokat és egy-két kattintással kész is a forráskód.
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/uml_code_gen.png" scale="50"/>
            </imageobject>
        </mediaobject>
        <para>
          A végeredmény egy .cpp és egy .h fájl. A header tartalmazza a mezőket és metódusokat, ám azok üresek, mivel a diagram csupán a metódus nevét, láthatóságát és argumentumait tartalmazza. Ezeken kívül létrehozott get/set metódusokat is a mezők lekérdezéséhez és módosításához.
        </para>
        <programlisting language="c"><![CDATA[#ifndef LZWBINFA_H
        #define LZWBINFA_H

        #include string

        /**
          * class LZWBinFa
          * osztályon belűl csak prototípusok legyenek,<<operátor kiiktatása,szeggyük külön
          * a programot 3 részre
          */

        class LZWBinFa
        {
        public:

         // Constructors/Destructors
         //

         /**
          * Empty Constructor
          */
         LZWBinFa ();

         /**
          * Empty Destructor
          */
         virtual ~LZWBinFa ();

         // Static Public attributes
         //

         // Public attributes
         //

         // Public attribute accessor methods
         //

         // Public attribute accessor methods
         //

         /**
          * @param  b
          */
         void operator_ (char b)
         {
         }

         /**
          */
         void kiir ()
         {
         }

         /**
          * A változatosság kedvéért ezeket az osztálydefiníció (class LZWBinFa {...};) után
          * definiáljuk,
          * hogy kénytelen légy az LZWBinFa és a :: hatókör operátorral minősítve definiálni
          * :) l. lentebb
          * @return int
          */
         int getMelyseg ()
         {
         }

         /**
          * @return double
          */
         double getAtlag ()
         {
         }

         /**
          * @return double
          */
         double getSzoras ()
         {
         }

         /**
          * @return std::ostream&
          * @param  os
          * @param  bf
          */
         std::ostream& operator_ (std::ostream& os, LZWBinFa& bf)
         {
         }

         /**
          * @param  os
          */
         void kiir (std::ostream& os)
         {
         }

         /**
          */
         void ki ()
         {
         }

         /**
          * @param  elem
          */
         void szabadit (Csomopont* elem)
         {
         }

        protected:

         // Static Protected attributes
         //

         // Protected attributes
         //

         // A fában tagként benne van egy csomópont, ez erősen ki van tüntetve, Ő a gyökér:
         Csomopont* gyoker;
         int maxMelyseg;
         double atlag;
         double szoras;
        public:

         // Protected attribute accessor methods
         //

        protected:

        public:

         // Protected attribute accessor methods
         //

         /**
          * Set the value of gyoker
          * A fában tagként benne van egy csomópont, ez erősen ki van tüntetve, Ő a gyökér:
          * @param new_var the new value of gyoker
          */
         void setGyoker (Csomopont* new_var)  {
           gyoker = new_var;
         }

         /**
          * Get the value of gyoker
          * A fában tagként benne van egy csomópont, ez erősen ki van tüntetve, Ő a gyökér:
          * @return the value of gyoker
          */
         Csomopont* getGyoker ()  {
          return gyoker;
         }

         /**
          * Set the value of maxMelyseg
          * @param new_var the new value of maxMelyseg
          */
         void setMaxMelyseg (int new_var)  {
           maxMelyseg = new_var;
         }

         /**
          * Get the value of maxMelyseg
          * @return the value of maxMelyseg
          */
         int getMaxMelyseg ()  {
          return maxMelyseg;
         }

         /**
          * Set the value of atlag
          * @param new_var the new value of atlag
          */
         void setAtlag (double new_var)  {
           atlag = new_var;
         }

         /**
          * Get the value of atlag
          * @return the value of atlag
          */
         double getAtlag ()  {
          return atlag;
         }

         /**
          * Set the value of szoras
          * @param new_var the new value of szoras
          */
         void setSzoras (double new_var)  {
           szoras = new_var;
         }

         /**
          * Get the value of szoras
          * @return the value of szoras
          */
         double getSzoras ()  {
          return szoras;
         }
        protected:

         /**
          * @param  elem
          */
         void rmelyseg (Csomopont* elem)
         {
         }

         /**
          * @param  elem
          */
         void ratlag (Csomopont* elem)
         {
         }

         /**
          * @param  elem
          */
         void rszoras (Csomopont* elem)
         {
         }

        private:

         // Static Private attributes
         //

         // Private attributes
         //

         // van nulla
         int vann;
         // nincs nulla
         int nincsn;
         // van egy
         int vane;
         // nincs egy
         int nincse;
         // Mindig a fa "LZW algoritmus logikája szerinti aktuális" csomópontjára mutat
         Csomopont* fa;
         // technikai
         int melyseg;
         int atlagosszeg;
         int atlagdb;
         double szorasosszeg;
        public:

         // Private attribute accessor methods
         //

        private:

        public:

         // Private attribute accessor methods
         //

         /**
          * Set the value of vann
          * van nulla
          * @param new_var the new value of vann
          */
         void setVann (int new_var)  {
           vann = new_var;
         }

         /**
          * Get the value of vann
          * van nulla
          * @return the value of vann
          */
         int getVann ()  {
          return vann;
         }

         /**
          * Set the value of nincsn
          * nincs nulla
          * @param new_var the new value of nincsn
          */
         void setNincsn (int new_var)  {
           nincsn = new_var;
         }

         /**
          * Get the value of nincsn
          * nincs nulla
          * @return the value of nincsn
          */
         int getNincsn ()  {
          return nincsn;
         }

         /**
          * Set the value of vane
          * van egy
          * @param new_var the new value of vane
          */
         void setVane (int new_var)  {
           vane = new_var;
         }

         /**
          * Get the value of vane
          * van egy
          * @return the value of vane
          */
         int getVane ()  {
          return vane;
         }

         /**
          * Set the value of nincse
          * nincs egy
          * @param new_var the new value of nincse
          */
         void setNincse (int new_var)  {
           nincse = new_var;
         }

         /**
          * Get the value of nincse
          * nincs egy
          * @return the value of nincse
          */
         int getNincse ()  {
          return nincse;
         }

         /**
          * Set the value of fa
          * Mindig a fa "LZW algoritmus logikája szerinti aktuális" csomópontjára mutat
          * @param new_var the new value of fa
          */
         void setFa (Csomopont* new_var)  {
           fa = new_var;
         }

         /**
          * Get the value of fa
          * Mindig a fa "LZW algoritmus logikája szerinti aktuális" csomópontjára mutat
          * @return the value of fa
          */
         Csomopont* getFa ()  {
          return fa;
         }

         /**
          * Set the value of melyseg
          * technikai
          * @param new_var the new value of melyseg
          */
         void setMelyseg (int new_var)  {
           melyseg = new_var;
         }

         /**
          * Get the value of melyseg
          * technikai
          * @return the value of melyseg
          */
         int getMelyseg ()  {
          return melyseg;
         }

         /**
          * Set the value of atlagosszeg
          * @param new_var the new value of atlagosszeg
          */
         void setAtlagosszeg (int new_var)  {
           atlagosszeg = new_var;
         }

         /**
          * Get the value of atlagosszeg
          * @return the value of atlagosszeg
          */
         int getAtlagosszeg ()  {
          return atlagosszeg;
         }

         /**
          * Set the value of atlagdb
          * @param new_var the new value of atlagdb
          */
         void setAtlagdb (int new_var)  {
           atlagdb = new_var;
         }

         /**
          * Get the value of atlagdb
          * @return the value of atlagdb
          */
         int getAtlagdb ()  {
          return atlagdb;
         }

         /**
          * Set the value of szorasosszeg
          * @param new_var the new value of szorasosszeg
          */
         void setSzorasosszeg (double new_var)  {
           szorasosszeg = new_var;
         }

         /**
          * Get the value of szorasosszeg
          * @return the value of szorasosszeg
          */
         double getSzorasosszeg ()  {
          return szorasosszeg;
         }
        private:

         /**
          * @param
          */
          LZWBinFa (const LZWBinFa& )
         {
         }

         /**
          * szokásosan: nocopyable
          * @return LZWBinFa&
          * @param
          */
         LZWBinFa& operator_ (const LZWBinFa& )
         {
         }

         /**
          * @param  elem
          * @param  os
          */
         void kiir (Csomopont* elem, std::ostream& os)
         {
         }

         void initAttributes () ;

        };

        #endif // LZWBINFA_H
]]>
        </programlisting>

    </section>

    <section>
        <title>Egy esettan</title>
        <para>
          A BME-s C++ tankönyv 14. fejezetét (427-444 elmélet, 445-469 az esettan) dolgozzuk fel!
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="mandelbort2/esettan/PiBBPBench.java">
            <filename>bhax/thematic_tutorials/bhax_textbook/liskov/antioo/PiBBPBench.java</filename>
            </link>
        </para>
        <para><command>
          Feladat:
        </command>
        Egy kereskedés számítógép-alkatrészek és számítógép-konfigurációk értékesítésével foglalkozik, Elsődle-
ges feladatunk egy olyan alkalmazás elkészítése, amely lehetőséget biztosít a kereskedés alkatrészeinek és
konfigurációinak nyilvántartására. Ennek keretében támogatnia kell a termékek állományból való betölté-
sét, képernyőre történő listázását, állományba való kiírását és az árképzés rugalmas kialakítását.
        </para>
        <para>
          A keretrendszerre vonatkozó követelmények a következők:
        </para>
        <itemizedlist>
                <listitem>
                    <para>
                      A keretrendszert úgy lehessen felhasználni, hogy ne kelljen kiadni a forráskódját.
                    </para>
                </listitem>
                <listitem>
                    <para>
                      A keretrendszernek támogatnia kell az egyes termékek adatfolyamból való betöltését, adatfolyamba való
                      kiírását és adatfolyamba(jellemzően képernyőre) történő formázott kiírását.
                    </para>
                </listitem>
                <listitem>
                    <para>
                      A termékek fontosabb attribútumai a következők: beszerzési ár, beszerzés dátuma, név és típus. Az aktuális ár a termék attribútumainak függvényében számítandó, a számítás módja fögghet a terméktípustól.
                    </para>
                </listitem>
                <listitem>
                    <para>
                      egy termék lehet elemi vagy összetett. Ez utóbbiak több termékből épülnek fel(példáúl számítógép konfiguráció), amelyek szintén lehetnek elemiek vagy akár osszetettek.
                    </para>
                </listitem>
        </itemizedlist>
        <para>
          Az alkalmazásra vonatkozó követelmények:
        </para>
        <itemizedlist>
                <listitem>
                    <para>
                      A támogatott termékek a következők (zárójelben az attribútumokkal): kijelző(szélesség és magasság hüvelykben), merevlemezes egység (sebesség RPM-ben), számítógép-konfiguráció. Az utóbbi összetett termék.
                    </para>
                </listitem>
        </itemizedlist>
        <para>
          A <function>ProductInventoryLib</function> könyvtár fogja tartalmazni a keretrendszer osztályait, így a
 csak a lefordított könyvtárra és az osztálydefíniciókat tartalmazó fejlécállományokra van
szükség. A Teljes alkalmazás helyett elkészítjük a <function>ProductInventoryTest</function> alkalmazást. A köztük levő kapcsolatokat a következő ábra szemlélteti:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/keretr.png" scale="50"/>
            </imageobject>
        </mediaobject>
        <programlisting language="c"><![CDATA[
// File: product.h
#ifndef PRODUCT_H
#define PRODUCT_H
#include <iostream>
#include <ctime>
class Product
{
protected:
  int initialPrice; //Beszerzési ár
  time_t dateOfAcquisition; // Beszerzés dátuma
  std::string name; // Név
  virtual void printParams(std::ostream& os) const;
  virtual void loadParamsFromStream(std::istream& is);
  virtual void writeParamstoStream(std::ostream& os) const;
public:
  Product();
  Product(std::string name, int initialPrice, time_t
  dateOfAcqusition);
  virtual ~Product() {};
  int GetInitialPrice() const;
  std::string GetName() const;
  time_t GetDateOfAcqusition() const;
  int GetAge() const;
  virtual int GetCurrentPrice() const;
  vouid Print(std::ostream& os) const;
  virtual std::string GetType() const = 0;
  virtual char GetCharCode() const = 0;
  friend std::istream& operator>>(std::istream& is,
  Product& product);
  friend std::ostream& operator<<(std::ostream& os,
  const Product& product);
};
#endif /* PRODUCT_H */
]]>
        </programlisting>
        <para>
          A <function>Product</function> osztály protected tagváltozói az <function>initialPrice</function>(int), <function>dateOfAcquisition</function>(time_t) és a <function>name</function>(std::string). Ezek értékeihez csupán a hozzájuk tartozó get függvényekkel juthatunk hozzá.
        </para>
        <programlisting language="c"><![CDATA[
  int GetInitialPrice() const;
  std::string GetName() const;
  time_t GetDateOfAcqusition() const;
]]>
        </programlisting>
        <para>
          Az aktuális dátum és a beszerzési datum alapján a <function>GetAge()</function> visszaadja a termék korát.
        </para>
        <programlisting language="c"><![CDATA[
  int Product::GetAge() const
  {
  time_t currentTime;
  time(&currentTime);
  double timeDiffInSec = difftime(currentTime, dateOfAcqusition);
  return (int)(timeDiffInSec/(3600*24));
  }
]]>
        </programlisting>
        <para>
          Mivel az aktuális ár kiszámítása termékfüggő, ezért a <function>GetCurrentPrice()</function> függvényt virtuálisnak deklaráltuk, hogy azt majd a leszarmazott felülírja. Ez a <function>HardDisk</function> osztály esetén így néz ki:
        </para>
        <programlisting language="c"><![CDATA[
class HardDisk : public Product
{
        int speedRPM;
      public:
        int GetCurrentPrice() const
          ...
};

        int HardDisk::GetCurrentPrice() const
        {
          int ageInDays = GetAge();
          if (ageInDays < 30)
            return initialPrice;
          else if (ageInDays >= 30 && ageInDays < 90)
            return (int)(initialPrice * 0.9);
          else
            return (int)(initialPrice *0.8);
        }
]]>
        </programlisting>




    </section>

    <section>
        <title>BPMN</title>
        <para>
          Rajzoljunk le egy tevékenységet BPMN-ben!
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_7.pdf (34-47 fólia)
        </para>
        <para>
          A BPMN széles körben használt és elfogadott módja a folyamatok ábrázolásának. Ilyen ábrák készítéséhez a következő eszközök állnak a rendelkezésünkre:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/bpmn_tut.png" scale="75"/>
            </imageobject>
        </mediaobject>
        <para>
          Példa: panaszlevelet küld egy vásárló. A support részleg elküldi válaszát a vásárlónak és vár a visszajelzésre. Ha a vásárló 2 napig nem válaszol, akkor nem foglalkoznak vele többet. Ha viszont válaszol, de válaszában további elégedetlenségét nyilvánítja ki, akkor az ide-oda levelezés tovább folytatódik amíg a vásárló elégedett nem lesz és így le nem zárul az ügy.
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/bpmn.png" scale="75"/>
            </imageobject>
        </mediaobject>



    </section>

    <section>
        <title>TeX UML</title>
        <para>
          Valamilyen TeX-es csomag felhasználásával készíts szép diagramokat az OOCWC projektről (pl.
  use case és class diagramokat).
        </para>
        <para>
            Megoldás forrása:

        </para>

        <para>

        </para>


    </section>


</chapter>
