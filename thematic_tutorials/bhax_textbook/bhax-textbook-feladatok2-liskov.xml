<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Liskov!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Liskov helyettesítés sértése</title>
        <para>
          Írjunk olyan OO, leforduló Java és C++ kódcsipetet, amely megsérti a Liskov elvet! Mutassunk rá a megoldásra: jobb OO tervezés.
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_1.pdf (93-99 fólia)
(számos példa szerepel az elv megsértésére az UDPROG repóban, lásd pl. source/binom/Batfai-
Barki/madarak/)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="liskov/lisk_hely/LiskSert.java">
            <filename>bhax/thematic_tutorials/bhax_textbook/liskov/lisk_hely/LiskSert.java</filename>
            </link>
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="liskov/lisk_hely/LiskRaFigyel.java">
            <filename>bhax/thematic_tutorials/bhax_textbook/liskov/lisk_hely/LiskRaFigyel.java</filename>
            </link>
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="liskov/lisk_hely/lisks.cpp">
            <filename>bhax/thematic_tutorials/bhax_textbook/liskov/lisk_hely/lisks.cpp</filename>
            </link>
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="liskov/lisk_hely/liskrf.cpp">
            <filename>bhax/thematic_tutorials/bhax_textbook/liskov/lisk_hely/liskrf.cpp</filename>
            </link>
        </para>
        <para>
          Liskov elve szerint egy típushierarchia szülő osztályokból és származtatott osztályokból áll úgy, hogy a származtatott osztályok rendelkeznek a szülő osztály összes tulajdonságával és viselkedésével plusz valami extrával. Hozzunk létre egy osztályt az autóknak, amely tartalmazza egy autó általános jellemzőit. Ezután származtassuk belőle az Audi osztályt. Ezután a <function>drive</function> metódusnak átadunk egy Car vagy Audi típusú objektumot. Minden jól megy, az autókat tudjuk vezetni, de a gyerekünknek is megtetszik az autózás, ezért a <function>Car</function>-ból származtatva létrehozzunk egy játék autó (<function>ToyBMW</function>) osztályt, hogy legyen mivel játszania. Előbb vagy utóbb észrevesszük, hogy az általunk kreált osztályhierarchia nem reális, hiszen egy játék autót nem lehet vezetni. Megsértettük a Liskov elvet.
        </para>
        <programlisting language="c"><![CDATA[public class LiskSert{

          void drive(Car c){
            c.go();
            //...
          }

          public static void main(String[] args){

            Car c = new Car();
            drive(c);

            Audi a = new Audi();
            drive(a);

            ToyBMW tbmw = new ToyBMW();
            drive(tbmw); // this is a problem, because you can't drive drive a toy car

          }

        }

        class Car{
          void go(){}
        }

        class Audi extends Car{
          // no problem, because you can drive a car
        }

        class ToyBMW extends Car{
          // but you can't drive a toy car
        }]]>
        </programlisting>
        <para>
          Hogy helyrehozzuk a hibánkat, beiktatunk egy köztes <function>RealCar</function> osztályt a <function>Car</function> és az <function>Audi</function> és egyéb vezethető autók közé.
        </para>
        <programlisting language="c"><![CDATA[public class LiskRaFigyel{

          void drive(RealCar rc){
            rc.go();
            //...
          }

          public static void main(String[] args){

            Audi a = new Audi();
            drive(a);

            //ToyBMW tbmw = new ToyBMW();
            //drive(tbmw);  this is a problem, because you can't drive drive a toy car

          }

        }

        class Car{}

        class RealCar extends Car{
          void go(){}
        }

        class Audi extends RealCar{
          // no problem, because you can drive a car
        }

        class ToyBMW extends Car{
          // but you can't drive a toy car
        }]]>
        </programlisting>


    </section>

    <section>
        <title>Szülő-gyerek</title>
        <para>
          Írjunk Szülő-gyerek Java és C++ osztálydefiníciót, amelyben demonstrálni tudjuk, hogy az ősön
keresztül csak az ős üzenetei küldhetőek!
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_1.pdf (98. fólia)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="liskov/szulo_gyerek/java/Osztaly.java">
            <filename>bhax/thematic_tutorials/bhax_textbook/liskov/szulo_gyerek/java/Osztaly.java</filename>
            </link>
        </para>
        <para>
          <link xlink:href="liskov/szulo_gyerek/c++/szulogyerek.cpp">
          <filename>bhax/thematic_tutorials/bhax_textbook/liskov/szulo_gyerek/c++/szulogyerek.cpp</filename>
          </link>
        </para>
        <para>
          Javában: létrehozunk egy osztályt, ami a "szűlő" osztály lesz és létrehozzuk a <function>kiir</function> metódust. Származtatunk belőle egy "gyerek" osztályt. Itt túlterheljük az ősosztály <function>kiir</function> metódusát és létrehozunk egy új (<function>ujKiir</function>) metódust is. A tartalmuk lényegtelen, mivel minket egyedül a metódusok elérhetősége érdekel. Ezután jöhet is a tesztelés, ahol létrehozunk egy "gyerek" típusú objektumot, amire egy "szülő" típusú referencia mutat:
        </para>
        <programlisting language="c"><![CDATA[public class Osztaly{

          public static void main(String[] args){
            Szulo sz = new Gyerek();
            sz.kiir();
            sz.ujKiir();
          }
        }

        class Szulo{
          public void kiir(){
            System.out.println("Szulo");
          }
        }

        class Gyerek extends Szulo{

          public void kiir(){
            System.out.println("Gyerek");
          }

          public void ujKiir(){
            System.out.println("uj");
          }

        }

        $ javac Osztaly.java
Osztaly.java:6: error: cannot find symbol
    sz.ujKiir();
      ^
  symbol:   method ujKiir()
  location: variable sz of type Szulo
1 error
]]>
        </programlisting>
        <para>
          A fordítás sikertelen, ugyanis a <function>Szulo</function> nem ismeri a <function>Gyerek</function> által létrehozott új metódust. Viszont ha a túlterhelt metódust próbáljuk elérni, akkor az eredmény:
        </para>
        <programlisting language="c"><![CDATA[$ java Osztaly
Gyerek
]]>
        </programlisting>
        <para>
          Ez a dinamikus kötésnek köszönhető, amely futási időben rendeli hozzá a metódust az objektumhoz. Javában ez alapértelmezett. Statikus kötést (fordítás során történik) is elérhetünk ha a <function>static</function> kulcsszóval deklaráljuk. Ekkor viszont a szülő metódusa fog lefutni.
        </para>

    </section>

    <section>
        <title>Anti OO</title>
        <para>
          A BBP algoritmussal a Pi hexadecimális kifejtésének a 0. pozíciótól számított 10<superscript>6</superscript>, 10<superscript>7</superscript>, 10<superscript>8</superscript> darab
jegyét határozzuk meg C, C++, Java és C# nyelveken és vessük össze a futási időket!
https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apas03.html#id561066
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="liskov/antioo/PiBBPBench.java">
            <filename>bhax/thematic_tutorials/bhax_textbook/liskov/antioo/PiBBPBench.java</filename>
            </link>
        </para>
        <para>
            <link xlink:href="liskov/antioo/PiBBPBench.cs">
            <filename>bhax/thematic_tutorials/bhax_textbook/liskov/antioo/PiBBPBench.cs</filename>
            </link>
        </para>
        <para>
            <link xlink:href="liskov/antioo/pi_bbp_bench.c">
            <filename>bhax/thematic_tutorials/bhax_textbook/liskov/antioo/pi_bbp_bench.c</filename>
            </link>
        </para>
        <para>
          A BBP algoritmusnak jóvoltából képesek vagyunk másodpercek alatt kiszámoltatni a Pi hexadecimális kifejtésének 0. pozíciótól számított szinte akárhány darab jegyét. Viszont minnél távolabbi értékeket vizsgálunk, annál inkább számít a teljesítmény. Először vizsgáljuk meg a java verziót. A d+1. hexa jegytől számoljuk a hexa jegyeket, amely deklarálása a <function>for</function> ciklus fejlécében szerepel.
        </para>
        <programlisting language="c"><![CDATA[
          ...
          int jegy = 0;

          long delta = System.currentTimeMillis();

          for(int d=1000000; d<1000001; ++d) {

              d16Pi = 0.0d;

              d16S1t = d16Sj(d, 1);
          ...

$  java PiBBPBench
6
1.803

$ java PiBBPBench
7
21.935

$ java PiBBPBench
12
243.427
]]>
        </programlisting>

        <literallayout>
* A számításokat az alábbi erőforrásokkal felszerelt gépen végeztem:
OS: Ubuntu 18.04 Lts
CPU: intel core i5 6300HQ
RAM: 8 GB 2133 MT/s DDR4
        </literallayout>



    </section>

    <section>
        <title>Hello, Android!</title>
        <para>
          Élesszük fel az SMNIST for Humans projektet!
https://gitlab.com/nbatfai/smnist/tree/master/forHumans/SMNISTforHumansExp3/app/src/main
Apró módosításokat eszközölj benne, pl. színvilág.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="liskov/">
            <filename>bhax/thematic_tutorials/bhax_textbook/liskov/</filename>
            </link>
        </para>
        <para>

        </para>



    </section>

    <section>
        <title>Ciklomatikus komplexitás</title>
        <para>
          Számoljuk ki valamelyik programunk függvényeinek ciklomatikus komplexitását! Lásd a fogalom
tekintetében a https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_2.pdf (77-79
fóliát)!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:

        </para>

        <para>

        </para>


    </section>


</chapter>
