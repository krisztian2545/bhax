<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Anonym!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>FUTURE tevékenység editor</title>
        <para>
          Javítsunk valamit a ActivityEditor.java JavaFX programon!
https://github.com/nbatfai/future/tree/master/cs/F6
Itt láthatjuk működésben az alapot: https://www.twitch.tv/videos/222879467
        </para>
        <para>
          A fordító nem látja a JavaFX-et
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/future_error.png" scale="30"/>
            </imageobject>
        </mediaobject>



    </section>

    <section>
        <title>OOCWC Boost ASIO hálózatkezelése</title>
        <para>
          Mutassunk rá a scanf szerepére és használatára! https://github.com/nbatfai/robocar-
emulator/blob/master/justine/rcemu/src/carlexer.ll
        </para>
        <para>

        </para>



    </section>

    <section>
        <title>BrainB</title>
        <para>
          Mutassuk be a Qt slot-signal mechanizmust ebben a projektben: https://github.com/nbatfai/esport-
    talent-search
        </para>
        <para>
          A program futtatásához szükség van Qt és opencv telepítéséhez, amit a következő parancsokkal érhetünk el Ubuntu rendszeren:
        </para>
        <programlisting><![CDATA[
          sudo apt-get install libqt4-dev
          sudo apt-get install libopencv-dev]]>
        </programlisting>
        <para>
          Először töltsük le a forrásfájlokat a feladatleírásból, majd a következő parancsokkal létrehozzuk, fordítjuk és futtatjuk a projektet:
        </para>
        <programlisting><![CDATA[
          $ qmake -project
          $ qmake BrainB.pro
          $ make
          $ ./BrainB
          ]]>
        </programlisting>
        <para>
          A program 10 percig fut. Addig az a dolgunk, hogy a bal egérgombot nyomva tartva a Samu Entropy-n tartsuk az egeret. 10 perc után a program kiírja a statisztikánkat.
        </para>
        <para>
          A forráskódban a slot-signal mechanizmust használtuk. Ez a mechanizmus teljesen független a GUI események ciklusaitól. Ezek különálló void típusú függvények. A slot függvények kezelik a signalokat, amelyeket a <function>connect()</function> függvénnyel kapcsolunk össze. Ezért fontos, hogy a signal paraméterlistája megegyezzen az őt fogadó slot paraméterlistájával, ugyanis a signal át kell hogy adja a paraméterként kapott adatait a hozzá kapcsolt slot-oknak.
        </para>
        <para>
          A signal függvényeket arra használjuk, hogy tudassuk a programmal/figyelővel, hogy változás történt. Az <function>emit</function> kulcsszóval tudjuk meghívni őket. Meghíváskor lefut az összes hozzá kapcsolt slot függvény.
        </para>
        <para>
          ...
        </para>
        <para>
          Például a BrainB programban összekapcsoltuk a <function>heroesChanged()</function> signalt a <function>updateHeroes()</function> slottal. A <function>connect( sender, signal, reciever, slot )</function> függvénynek először megadjuk a signalt küldő objektumot ( ez esetben a <function>brainBThread</function>-ot, és ha megnézzük a forrást, akkor láthatjuk, hogy ő hívja meg a jelet: <function>emit heroesChanged ( dest, heroes[0].x, heroes[0].y );</function> ), a signalt a paramétereinek típusaival együtt, egy mutatót a slot-ot tartalmazó objektumra (ez esetben <function>this</function>, mert ez a kód a BrainBWin.cpp-ben szerepel, és a slot is itt van definiálva), valamint a slot metódust paramétereinek típusaival együtt.
        </para>
        <programlisting><![CDATA[connect ( brainBThread, SIGNAL ( heroesChanged ( QImage, int, int ) ), this, SLOT ( updateHeroes ( QImage, int, int ) ) );]]>
        </programlisting>


    </section>

    <section>
        <title>SamuCam</title>
        <para>
          Mutassunk rá a webcam (pl. Androidos mobilod) kezelésére ebben a projektben:
  https://github.com/nbatfai/SamuCam
        </para>
        <para>
          A program fordításához és futtatásáhzo szükség van a Qt és az opencv telepítésére (lásd az előző feladatban).
        </para>
        <para>
          A kamerát kezelő SamuCam osztály a <function>QThread</function> leszármazottja. Egy ilyen objektum egy szálat vezérel a programon belül. Futása a <function>run()</function> metódusban kezdődik.
        </para>
        <para>
          SamuCam.h
        </para>
        <programlisting language="c++"><![CDATA[
        class SamuCam : public QThread
        {
            Q_OBJECT

        public:
            SamuCam ( std::string videoStream, int width, int height );
            ~SamuCam();

            void openVideoStream();
            void run();

        private:
            std::string videoStream;
            cv::VideoCapture videoCapture;
            int width;
            int height;
            int fps;

        signals:
            void faceChanged ( QImage * );
            void webcamChanged ( QImage * );
        };]]>
        </programlisting>
        <para>
          A konstruktor csupán beállítja a privát változóit a kapott értékek alapján és meghívja az <function>openVideoStream()</function> metódust. Itt inicializáljuk a kamerát és beállítjuk azt. A <function>videoCapture.open ( 0 );</function> metódusnak 0-t adtunk paraméterül hogy az alapértelmezett kamera (esetemben laptop beépített kamerája) kerüljön használatra.
        </para>
        <programlisting><![CDATA[
          SamuCam::SamuCam ( std::string videoStream, int width = 176, int height = 144 )
            : videoStream ( videoStream ), width ( width ), height ( height )
          {
            openVideoStream();
          }

          void SamuCam::openVideoStream()
          {
            videoCapture.open ( 0 );

            videoCapture.set ( CV_CAP_PROP_FRAME_WIDTH, width );
            videoCapture.set ( CV_CAP_PROP_FRAME_HEIGHT, height );
            videoCapture.set ( CV_CAP_PROP_FPS, 10 );
          }
          ]]>
        </programlisting>
        <para>
          Visszatérve a <function>run()</function> metódushoz, a <function>CascadeClassifier</function> típusú <function>faceClassifier</function> objektum teszi lehetővé az arcok felismerését. A kamera kezelése a <function>videoCapture</function>-on keresztül történik. Az <function>isOpened()</function> függvénnyel vizsgáljuk, hogy a él-e a kapcsolat a kamerával és ha nem, akkor ismét meghívja az <function>openVideoStream()</function>-et. A <function>videoCapture.read ( frame )</function> megragadja számunkra a pillanatot, ami ha sikerül (<function>if ( !frame.empty() ) {...}</function>), akkor a <function>faceClassifier.detectMultiScale()</function> eljárás megkeresi az arcokat a képen, amiket majd a második paraméterként átadott <function>faces</function> vektorba tárol négyzetek formájában (1 négyzet 1 arcot vesz körül).
        </para>
        <programlisting><![CDATA[
          void SamuCam::run()
          {

            cv::CascadeClassifier faceClassifier;

            std::string faceXML = "lbpcascade_frontalface.xml"; // https://github.com/Itseez/opencv/tree/master/data/lbpcascades

            if ( !faceClassifier.load ( faceXML ) )
              {
                qDebug() << "error: cannot found" << faceXML.c_str();
                return;
              }

            cv::Mat frame;

            while ( videoCapture.isOpened() )
              {

                QThread::msleep ( 50 );
                while ( videoCapture.read ( frame ) )
                  {

                    if ( !frame.empty() )
                      {

                        cv::resize ( frame, frame, cv::Size ( 176, 144 ), 0, 0, cv::INTER_CUBIC );

                        std::vector<cv::Rect> faces;
                        cv::Mat grayFrame;

                        cv::cvtColor ( frame, grayFrame, cv::COLOR_BGR2GRAY );
                        cv::equalizeHist ( grayFrame, grayFrame );

                        faceClassifier.detectMultiScale ( grayFrame, faces, 1.1, 4, 0, cv::Size ( 60, 60 ) );

                        if ( faces.size() > 0 )
                          {

                            cv::Mat onlyFace = frame ( faces[0] ).clone();

                            QImage* face = new QImage ( onlyFace.data,
                                                        onlyFace.cols,
                                                        onlyFace.rows,
                                                        onlyFace.step,
                                                        QImage::Format_RGB888 );

                            cv::Point x ( faces[0].x-1, faces[0].y-1 );
                            cv::Point y ( faces[0].x + faces[0].width+2, faces[0].y + faces[0].height+2 );
                            cv::rectangle ( frame, x, y, cv::Scalar ( 240, 230, 200 ) );


                            emit  faceChanged ( face );
                          }

                        QImage*  webcam = new QImage ( frame.data,
                                                       frame.cols,
                                                       frame.rows,
                                                       frame.step,
                                                       QImage::Format_RGB888 );

                        emit  webcamChanged ( webcam );

                      }

                    QThread::msleep ( 80 );

                  }

                if ( ! videoCapture.isOpened() )
                  {
                    openVideoStream();
                  }

              }

          }
          ]]>
        </programlisting>



    </section>

    <section>
        <title>OSM térképre rajzolása</title>
        <para>
          Debrecen térképre dobjunk rá cuccokat, ennek mintájára, ahol én az országba helyeztem el a DEAC
hekkereket: https://www.twitch.tv/videos/182262537 (de az OOCWC Java Swinges
megjelenítőjéből:
https://github.com/nbatfai/robocar-emulator/tree/master/justine/rcwin
is kiindulhatsz, mondjuk az komplexebb, mert ott időfejlődés is van...)
        </para>


    </section>


</chapter>
