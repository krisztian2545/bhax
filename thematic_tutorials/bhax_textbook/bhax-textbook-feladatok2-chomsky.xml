<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Encoding</title>
        <para>
          Fordítsuk le és futtassuk a Javat tanítok könyv MandelbrotHalmazNagyító.java forrását úgy, hogy a
fájl nevekben és a forrásokban is meghagyjuk az ékezetes betűket!
<link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/adatok.html">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/adatok.html</link>
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="chomsky2/encoding/MandelbrotHalmazNagyító.java">
            <filename>bhax/thematic_tutorials/bhax_textbook/chomsky2/encoding/MandelbrotHalmazNagyító.java</filename>
            </link>
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="chomsky2/encoding/MandelbrotHalmaz.java">
            <filename>bhax/thematic_tutorials/bhax_textbook/chomsky2/encoding/MandelbrotHalmaz.java</filename>
            </link>
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="chomsky2/encoding/MandelbrotIterációk.java">
            <filename>bhax/thematic_tutorials/bhax_textbook/chomsky2/encoding/MandelbrotIterációk.java</filename>
            </link>
        </para>
        <para>
          Általában nem szokás és nem is ajánlott ékezeteket használnunk a fájlnevekben és a forráskódban (mivel kicsi az esélye annak, hogy a kódodat csak magyarok fogják olvasni és így "mások" nem fogják érteni az azonosítóidat és bizonyos esetben a fordító encode-olási hibába ütközhet a kódod értelmezésekor), de nem árt ha tisztában vagyunk vele, hogy ez is lehetséges.
        </para>
        <para>
          <command>-encoding encoding</command>

    Sets the source file encoding name, such as EUC-JP and UTF-8. If the -encoding option is not specified, then the platform default converter is used.

        </para>
        <para>
          A <command>javac</command> parancs után az <function>-encoding</function> kapcsolóval megmondhatjuk a fordítónak, hogy melyik encode-olás szerint értelmezze a forráskódunk. Ha ezt nem adjuk meg, akkor az alapértelmezett beállítás szerint végzi el. A támogatott kódolások listáját megtalálod <link xlink:href="https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html">itt</link>.
        </para>
        <para>
          A fordításhoz az <function>UTF-8</function>-as kódolást használtam, ami biztosítja hogy a fordító értelmezni tudja a magyar nyelv ékezetes betűit.
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/mandelbro.png" scale="35"/>
            </imageobject>
        </mediaobject>
        <para>
          Ha az alapértelmezett encode-olás <function>UTF-8</function>-ra van állítva, az <function>-encoding</function> kapcsoló elhanyagolható.
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/mandelbro2.png" scale="35"/>
            </imageobject>
        </mediaobject>




    </section>

    <section>
        <title>OOCWC lexer</title>
        <para>
          Izzítsuk be az OOCWC-t és vázoljuk a <link xlink:href="https://github.com/nbatfai/robocar-emulator/blob/master/justine/rcemu/src/carlexer.ll">https://github.com/nbatfai/robocar-emulator/blob/master/justine/rcemu/src/carlexer.ll</link> lexert és kapcsolását a programunk OO struktúrájába!
        </para>

        <para>

        </para>


    </section>

    <section>
        <title>Paszigráfia Rapszódia OpenGL full screen vizualizáció</title>
        <para>
          Lásd vis_prel_para.pdf! Apró módosításokat eszközölj benne, pl. színvilág, textúrázás, a szintek jobb
elkülönítése, kézreállóbb irányítás.
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="chomsky2/pasz_opengl/para6.cpp">
            <filename>bhax/thematic_tutorials/bhax_textbook/chomsky2/pasz_opengl/para6.cpp</filename>
            </link>
        </para>

        <para>
          A PaRa (Paszigráfia Rapszódia) egy mesterséges nyelv kialakítására való törkvés, amely lehetővé teszi a homunkulusz és a mesterséges homunkulusz közötti kommunikációt, ergó ez az esport kultúra nyelve. Az SMNIST-el ellentétben itt nem a pöttyök száma, hanem azok pontos elhelyezkedése számít.
        </para>
        <para>
          A vizualizáláshoz az OpenGL könyvtárat fogjuk használni. Az importálást a következő sor teszi lehetővé:
        </para>
        <programlisting><![CDATA[#include <GL/glut.h>]]>
        </programlisting>
        <para>
          A színvilág megváltoztatásához a <function>glColor3f()</function> metódusnak kell megadni 3 float típusú értéket, amelyek a vörös, zöld és kék színek (RGB) értékei. Ezeket mindíg a <function>glBegin()</function> után hívjuk meg, mivel pl.: a <function>glBegin ( GL_LINES )</function> után a vonal színét állítjuk amíg azt a <function>glEnd()</function> paranccsal be nem zárjuk. Ezek a színezések a <function>drawPaRaCube()</function> metódusban helyezkednek el.
        </para>
        <para>
          A háttérszín megváltoztatásához a <function>glClearColor()</function> paramétereit kell átírni, amelyek a 3 RGB + alpha értékek float típussal. Ez viszont már a <function>draw()</function> metódusban van.
        </para>
        <programlisting><![CDATA[
        void draw ( void )
        {
                glClearColor ( .8f, .8f, .8f, .8f );

                ...
        }]]>
        </programlisting>
        <para>
          A <function>keyboard()</function> metódust kiegészítettem a fullscreen opcióval, amelyet "f" gombbal tudunk be- és kikapcsolni. A teljes képernyős modba a <function>glutFullScreen()</function> paranccsal kerülünk és az ablak újraméretezésével kerülünk ki onnan: <function>glutReshapeWindow(640 , 480)</function> .
        </para>
        <programlisting><![CDATA[
          void keyboard ( unsigned char key, int x, int y )
          {
                  if ( key == '0' ) {
                          index=0;
                  } else if ( key == '1' ) {
                          index=1;
                  } else if ( key == '2' ) {
                          index=2;
                  } else if ( key == '3' ) {
                          index=3;
                  } else if ( key == '4' ) {
                          index=4;
                  } else if ( key == '5' ) {
                          index=5;
                  } else if ( key == '6' ) {
                          index=6;
                  } else if ( key == 't' ) {
                          transp = !transp;
                  } else if ( key == '-' ) {
                          ++fovy;

                          glMatrixMode ( GL_PROJECTION );
                          glLoadIdentity();
                          gluPerspective ( fovy, ( float ) w/ ( float ) h, .1f, 1000.0f );
                          glMatrixMode ( GL_MODELVIEW );

                  } else if ( key == '+' ) {
                          --fovy;

                          glMatrixMode ( GL_PROJECTION );
                          glLoadIdentity();
                          gluPerspective ( fovy, ( float ) w/ ( float ) h, .1f, 1000.0f );
                          glMatrixMode ( GL_MODELVIEW );

                  } else if ( key == 'f' ) {

                    fullScreen = !fullScreen;
                    if (fullScreen) {
                      glutFullScreen();
                    } else {
                      glutReshapeWindow(640 , 480);
                    }

                  }

                  glutPostRedisplay();

          }
          ]]>
        </programlisting>
        <para>
          A program fordításához használt parancs: <command>g++ para6.cpp -o para -lboost_system -lGL -lGLU -lglut</command>
        </para>
        <para>
          A futtatáshoz pedig: <command>./para 3:2:1:1:0:3:2:1:0:2:0:2:1:1:0:3:3:0:2:0:1:1:0:1:0:1:0:1:0:2:2:0:1:1:1:3:2:1:0:2:0:2:1:1:1:2:3:0:1:1:1:1:0:3:3:0:1:0:2:1:0:1:0:2:2:0:0:0:1:3:1:0:1:3:2:1:0:2:0:3:3:0:1:0:2:1:0</command>
        </para>

        <mediaobject>
            <imageobject>
                <imagedata fileref="images/para.png" scale="50"/>
            </imageobject>
        </mediaobject>
        <para>
          Átlátszó módban:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/para2.png" scale="50"/>
            </imageobject>
        </mediaobject>
        <para>
          Teljes képernyő módban:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/para3.png" scale="20"/>
            </imageobject>
        </mediaobject>




    </section>

    <section>
        <title>Paszigráfia Rapszódia LuaLaTeX vizualizáció</title>
        <para>
          Lásd vis_prel_para.pdf! Apró módosításokat eszközölj benne, pl. színvilág, még erősebb 3D-s hatás.
        </para>




    </section>

    <section>
        <title>Perceptron osztály</title>
        <para>
          Dolgozzuk be egy külön projektbe a projekt Perceptron osztályát!
Lásd <link xlink:href="https://youtu.be/XpBnR31BRJY">https://youtu.be/XpBnR31BRJY</link>
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="chomsky2/perceptron/mandel.cpp">
            <filename>bhax/thematic_tutorials/bhax_textbook/chomsky2/perceptron/mandel.cpp</filename>
            </link>
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="chomsky2/perceptron/main.cpp">
            <filename>bhax/thematic_tutorials/bhax_textbook/chomsky2/perceptron/main.cpp</filename>
            </link>
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="chomsky2/perceptron/mlp.hpp">
            <filename>bhax/thematic_tutorials/bhax_textbook/chomsky2/perceptron/mlp.hpp</filename>
            </link>
        </para>

        <para>
          Gépi tanulásban a perceptron egy bináris osztályozás tanítására használt algoritmus, amely el tudja dönteni a bemenetről, hogy az benne van e az adott osztályban vagy sem.
        </para>
        <para>
          Először lefordítjuk a <function>mandel.cpp</function>-t, hogy aztán létrehozhassuk vele mandel.png-t. Később ez a kép lesz a bemenet a perceptronnak.
        </para>
        <programlisting><![CDATA[
$ g++ mandel.cpp -lpng16 -o3 -o mandel
$ ./mandel mandel.png
2114
21.1525 sec
mandel.png mentve]]>
        </programlisting>
        <para>
          A libpng  és libpng++ könyvtárkat a következő parancsokkal tudjuk feltelepíteni: <command>sudo apt-get install libpng-dev</command> és <command>sudo apt-get install libpng++-dev</command>
          A <function>-o3</function> kapcsoló 3-as szintű optimizálást jelent, hogy a program majd gyorsabb legyen, cserébe viszont tovább tart a fordítás.
        </para>

        <programlisting><![CDATA[
$ g++ mlp.hpp main.cpp -o perc -lpng -std=c++11
$ ./perc mandel.png
0.527632
$ ./perc mandel.png
0.696341 ]]>
        </programlisting>
        <para>
          Deklaráljuk a képet tartalmazó objektumunkat a parancssori argumentumban megadott fájlnév alapján.
        </para>
        <programlisting><![CDATA[int main (int argc, char **argv)
        {
            png::image <png::rgb_pixel> png_image (argv[1]);
            ...]]>
        </programlisting>
        <para>
          Ezután kiszámoljuk és eltároljuk a kép "méretét" (területét), amit felhasználunk a perceptron bemeneti méretének meghatározásához. Ugyígy az <function>image</function> változó deklarálásakor.
        </para>
        <programlisting><![CDATA[
int size = png_image.get_width() * png_image.get_height();

Perceptron* p = new Perceptron (3, size, 256, 1);

double* image = new double[size];]]>
        </programlisting>
        <para>
          Egyesével végigmegyünk a kép összes pixelén és azok <function>red</function> értékét eltároljuk az <function>image</function> tömbbe, így a ciklusok végére megkapjuk a kép vörös színértékeit egydimenziós formára konvertálva. Erre azért volt szükség, mert a perceptron ilyen formában igényeli a bemenetet.
        </para>
        <programlisting><![CDATA[
          for (int i = 0; i<png_image.get_width(); ++i)
              for (int j = 0; j<png_image.get_height(); ++j)
                  image[i*png_image.get_width() + j] = png_image[i][j].red;
          ]]>
        </programlisting>
        <para>
          Mostmár átadjuk a perceptronnak az értékeket és az eredményt elmentjük a <function>value</function> változóba. Végül már csak a kiíratás és a memória felszabadítása maraadt:
        </para>
        <programlisting><![CDATA[
          double value = (*p) (image);

          std::cout << value << std::endl;

          delete p;
          delete [] image;

          }
]]>
        </programlisting>


    </section>


</chapter>
