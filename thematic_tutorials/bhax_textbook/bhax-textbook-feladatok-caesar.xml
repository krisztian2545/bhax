<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Caesar!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title><type>double **</type> háromszögmátrix</title>
        <para>
            Írj egy olyan <function>malloc</function> és <function>free</function>
            párost használó C programot, amely helyet foglal
            egy alsó háromszög mátrixnak a szabad tárban!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/1MRTuKwRsB0">https://youtu.be/1MRTuKwRsB0</link>,
            <link xlink:href="https://youtu.be/RKbX5-EWpzA">https://youtu.be/RKbX5-EWpzA</link>.
        </para>
        <para>
            Megoldás forrása:          
            <link xlink:href="caesar/haromszog.c">
            <filename>bhax/thematic_tutorials/bhax_textbook/caesar/haromszog.c</filename>
            </link>
        </para>
        <para>
            Egy 5 soros háromszögmátrixot fogunk létrehozni. Ezt egy <function>double</function> típusú pointerekre mutató pointerrel fogjuk megvalósítani.
            A <function>malloc( size )</function> paranccsal lefoglaljuk a sorok mutatói számára a memóriát. Hogy tudjuk mennyi bájtot foglaljunk le, a <function>sizeof()</function> függvénnyel lekérjük egy <function>double</function> méretét és megszorozzuk a sorok számával és a visszaadott pointert <function>double **</function> típusúra kényszerítjük. Megvizsgáljuk, hogy nem e kapott valamelyik elem NULL értéket, mert az azt jelentené, hogy nincs elég memória és kilép a programból.
        </para>            
        <programlisting><![CDATA[    int nr = 5;
    double **tm;
    
    printf("%p\n", &tm);
    
    if ((tm = (double **) malloc (nr * sizeof (double *))) == NULL)
    {
        return -1;
    }]]>
        </programlisting>
        <para>
            A for ciklussal lefoglaljuk az egyre növekvő elemszámú sorok elemeinek a memóriáját, amit szintén megvizsgálunk a Null értékkel.
        </para>
        <programlisting><![CDATA[for (int i = 0; i < nr; ++i)
{
    if ((tm[i] = (double *) malloc ((i + 1) * sizeof (double))) == NULL)
    {
        return -1;
    }
}]]>
        </programlisting>
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/haromszog.jpg" scale="40"/>
            </imageobject>
        </mediaobject>
        <para>
            Az elemek értékeinek módosítgatási után a <function>free()</function> eljárás használatával felszabadítjuk először az elemekre, majd a sorokra lefoglalt memóriát. 
        </para>
        <programlisting><![CDATA[for (int i = 0; i < nr; ++i)
    free (tm[i]);

free (tm);]]>
        </programlisting>

    </section>        
    <section>
        <title>C EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót C-ben!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="caesar/e.c">
            <filename>bhax/thematic_tutorials/bhax_textbook/caesar/e.c</filename>
            </link>
        </para>
        <para>
            A titkosítást EXOR művelettel fogjuk végrehajtani egy általunk megadott kulcs és a titkosítandó szöveg között.
        </para>
        <para>
            A <function>kulcs_meret</function> változóban eltároljuk a futtatáskor átadott második argumentum (tehát a kulcs) hosszát. Majd a <function>strncpy( hova, honnan, méret )</function> függvénnyel a <function>kulcs</function> változóba másoljuk a kulcsot.
        </para>
        <programlisting><![CDATA[  int kulcs_meret = strlen (argv[1]);
  strncpy (kulcs, argv[1], MAX_KULCS);]]>
        </programlisting>
        <para>
            Folyamatosan beolvassuk a szöveget és a kulcs egyes elemeivel végrehajtjuk rajta a műveletet, miközben kiírjuk a titkosított szöveget a standard outputra.
        </para>
        <programlisting><![CDATA[while ((olvasott_bajtok = read (0, (void *) buffer, BUFFER_MERET)))
  {
    for (int i = 0; i < olvasott_bajtok; ++i)
    {

      buffer[i] = buffer[i] ^ kulcs[kulcs_index];
      kulcs_index = (kulcs_index + 1) % kulcs_meret;

	  }

    write (1, buffer, olvasott_bajtok);

  }]]>
        </programlisting>
        <para>
            A futtatáskor megadjuk a kulcsot a titkosításhoz és a kimenetet átirányítjuk a titkos.szoveg állományba:
        </para>
        <para>
            <command><![CDATA[./e 56789012 <tiszta.txt > titkos.szoveg]]></command>
        </para>
        

    </section>        
    <section>
        <title>Java EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót Java-ban!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
    <section>
        <title>C EXOR törő</title>
        <para>
            Írj egy olyan C programot, amely megtöri az első feladatban előállított titkos szövegeket!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="caesar/t.c">
            <filename>bhax/thematic_tutorials/bhax_textbook/caesar/t.c</filename>
            </link>
        </para>
        <para>
            <link xlink:href="caesar/t_par.c">
            <filename>bhax/thematic_tutorials/bhax_textbook/caesar/t_par.c</filename>
            </link>
        </para>
        <para>
            Hiába tudjuk milyen módon lett titkosítva a szöveg, ahhoz hogy dekódoljuk, meg kell találnunk a kulcsot. Ezt úgy fogjuk csinálni, hogy szépen sorba végigmegyünk az összes kulcson és közbe keresünk néhány "kulcsszót", amelyek gyakran előfordulhatnak, ezért ha megegyeznek a dekódolt szóval, akkor kiíratjuk ezt a kulcsot és a szöveget, mint lehetséges megoldás és tovább keresünk. Erre azért van szükség, mert megeshet, hogy a kulcsszavak helyesen lettek dekódolva, de ettől még sok karakter eltér a várt eredménytől.
        </para>
        <para>
            A kulcsok legenerálása és kipróbálása annyi egymásba ágyazott for ciklust igényel, amekkora a kulcs mérete. Ez esetben tudjuk, hogy 8 karakter hosszú.
        </para>
        <programlisting><![CDATA[    // osszes kulcs eloallitasa
    for (int ii = '0'; ii <= '9'; ++ii)
        for (int ji = '0'; ji <= '9'; ++ji)
            for (int ki = '0'; ki <= '9'; ++ki)
                for (int li = '0'; li <= '9'; ++li)
                    for (int mi = '0'; mi <= '9'; ++mi)
                        for (int ni = '0'; ni <= '9'; ++ni)
                            for (int oi = '0'; oi <= '9'; ++oi)
                                for (int pi = '0'; pi <= '9'; ++pi)
                                {
                                    kulcs[0] = ii;
                                    kulcs[1] = ji;
                                    kulcs[2] = ki;
                                    kulcs[3] = li;
                                    kulcs[4] = mi;
                                    kulcs[5] = ni;
                                    kulcs[6] = oi;
                                    kulcs[7] = pi;

                                    if (exor_tores (kulcs, KULCS_MERET, titkos, p - titkos))
                                        printf
                                        ("Kulcs: [%c%c%c%c%c%c%c%c]\nTiszta szoveg: [%s]\n",
                                         ii, ji, ki, li, mi, ni, oi, pi, titkos);

                                    // ujra EXOR-ozunk, igy nem kell egy masodik buffer
                                    exor (kulcs, KULCS_MERET, titkos, p - titkos);
                                }]]>
        </programlisting>
        <para>
            A következő 2 függvény fogja nekünk eldönteni, hogy rátaláltunk-e a keresett kulcsra. Ha az átlagos szóhossz 6 és 9 közé esik, valamit a dekódolt szövegben megtalálható a "hogy", a "nem", az "az" és a "ha" szavak, akkor kiírjuk a dekódolt szöveget.
        </para>
        <programlisting><![CDATA[double
atlagos_szohossz (const char *titkos, int titkos_meret)
{
    int sz = 0;
    for (int i = 0; i < titkos_meret; ++i)
        if (titkos[i] == ' ')
            ++sz;

    return (double) titkos_meret / sz;
}

int
tiszta_lehet (const char *titkos, int titkos_meret)
{
    // a tiszta szoveg valszeg tartalmazza a gyakori magyar szavakat
    // illetve az átlagos szóhossz vizsgálatával csökkentjük a
    // potenciális töréseket

    double szohossz = atlagos_szohossz (titkos, titkos_meret);

    return szohossz > 6.0 && szohossz < 9.0
           && strcasestr (titkos, "hogy") && strcasestr (titkos, "nem")
           && strcasestr (titkos, "az") && strcasestr (titkos, "ha");

}]]>
        </programlisting>
        <para>
            Mivel a kulcsok egyesével való kipróbálgatása elég időigényes, a for ciklusokat párhuzamosítjuk a végtelen ciklusoknál használt módon.
        </para>
        <programlisting><![CDATA[// osszes kulcs eloallitasa
#pragma omp parallel for private(kulcs)
    for (int ii = '0'; ii <= '9'; ++ii)
        for (int ji = '0'; ji <= '9'; ++ji)
            for (int ki = '0'; ki <= '9'; ++ki)
                for (int li = '0'; li <= '9'; ++li)
                    for (int mi = '0'; mi <= '9'; ++mi)
                        for (int ni = '0'; ni <= '9'; ++ni)
                            for (int oi = '0'; oi <= '9'; ++oi)
                                for (int pi = '0'; pi <= '9'; ++pi)
                                {
                                    kulcs[0] = ii;
                                    kulcs[1] = ji;
                                    kulcs[2] = ki;
                                    kulcs[3] = li;
                                    kulcs[4] = mi;
                                    kulcs[5] = ni;
                                    kulcs[6] = oi;
                                    kulcs[7] = pi;

                                    exor_tores (kulcs, KULCS_MERET, titkos, p - titkos);

                                }]]></programlisting>

    </section>        
    <section>
        <title>Neurális OR, AND és EXOR kapu</title>
        <para>
            R
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Koyw6IH5ScQ">https://youtu.be/Koyw6IH5ScQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>   
        
    </section>        
    <section>
        <title>Hiba-visszaterjesztéses perceptron</title>
        <para>
            C++
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
            <link xlink:href="caesar/percr.hpp">
            <filename>bhax/thematic_tutorials/bhax_textbook/caesar/percr.hpp</filename>
            </link>
        </para>
        <para>
            A feladat megoldásában tutorált engem: Szilágyi Csaba.
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
