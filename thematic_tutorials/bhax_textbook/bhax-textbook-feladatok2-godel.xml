<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gödel!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Gengszterek</title>
        <para>
          Gengszterek rendezése lambdával a Robotautó Világbajnokságban
https://youtu.be/DL6iQwPx1Yw (8:05-től)
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="stroustrup/jdk/jdk_counter.cpp">
            <filename>bhax/thematic_tutorials/bhax_textbook/stroustrup/jdk/jdk_counter.cpp</filename>
            </link>
        </para>
        <para>

        </para>

        <mediaobject>
            <imageobject>
                <imagedata fileref="images/mandelbro.png" scale="35"/>
            </imageobject>
        </mediaobject>


    </section>

    <section>
        <title>C++11 Custom Allocator</title>
        <para>
          https://prezi.com/jvvbytkwgsxj/high-level-programming-languages-2-c11-allocators/ a
CustomAlloc-os példa, lásd C forrást az UDPROG repóban!
        </para>

        <para>

        </para>


    </section>

    <section>
        <title>STL map érték szerinti rendezése</title>
        <para>
          Például: https://github.com/nbatfai/future/blob/master/cs/F9F2/fenykard.cpp#L180
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="chomsky2/pasz_opengl/para6.cpp">
            <filename>bhax/thematic_tutorials/bhax_textbook/chomsky2/pasz_opengl/para6.cpp</filename>
            </link>
        </para>

        <para>

        </para>
        <programlisting><![CDATA[#include <GL/glut.h>]]>
        </programlisting>


    </section>

    <section>
        <title>Alternatív Tabella rendezése</title>
        <para>
          Mutassuk be a <link xlink:href="https://progpater.blog.hu/2011/03/11/alternativ_tabella">https://progpater.blog.hu/2011/03/11/alternativ_tabella</link> a programban a java.lang
Interface Comparable&lt;T&gt; szerepét!
        </para>
        <para>
          Javában az Interface-ek hasonlóan működnek, mint az osztályok, de az Interface-ekben sosem határozzuk meg a metódusok törzsét, így ez a feladat arra az osztályra hárul, amelyik implementálja azt. Implementálni az <function>implements</function> kulcsszóval lehet és az interface neve után kisebb-nagyobb opoerátorok között megadjuk az osztály nevét. C++-al ellentétben, Javában az osztályok egyszerre csupán 1 osztály leszármazottai lehetnek, de interface-ekből többet is implementálhatnak.
        </para>
        <programlisting><![CDATA[class Csapat implements Comparable<Csapat> {
          ...
}]]>
        </programlisting>
        <para>
          Miután definiáltuk a <function>Csapat</function> osztály mezőit és metódusait, megírjuk a <function>Comparable</function> interface általunk használni kívánt <function>compareTo()</function> függvényének törzsét. A visszatérési érték egy <function>int</function> típusú pozitív vagy negatív szám vagy nulla. Ha a függvényt meghívó objektum <function>ertek</function> valtozója kisebb, mint az argumentumban átadotté, akkor az eredmény -1 lesz, jelezve ezzel, hogy az értékünk kisebb mint akihez hasonlítottuk azt, 1 lesz ha nagyobb értékünk van és 0 ha megegyeznek.
        </para>
        <programlisting><![CDATA[class Csapat implements Comparable<Csapat> {

  protected String nev;
  protected double ertek;

  public Csapat(String nev, double ertek) {
    this.nev = nev;
    this.ertek = ertek;
  }

  public int compareTo(Csapat csapat) {
    if (this.ertek < csapat.ertek) {
      return -1;
    } else if (this.ertek > csapat.ertek) {
      return 1;
    } else {
      return 0;
    }
  }
}]]>
        </programlisting>


    </section>

    <section>
        <title>Prolog családfa</title>
        <para>
          Ágyazd be a Prolog családfa programot C++ vagy Java programba! Lásd para_prog_guide.pdf!
        </para>


    </section>


</chapter>
