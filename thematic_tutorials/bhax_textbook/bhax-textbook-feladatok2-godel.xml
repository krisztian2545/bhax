<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gödel!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Gengszterek</title>
        <para>
          Gengszterek rendezése lambdával a Robotautó Világbajnokságban
https://youtu.be/DL6iQwPx1Yw (8:05-től)
        </para>
        <para>
          C++11-óta rendelkezésünkre áll az ún. lambda kifejezések létrehozására. Ezek úgy működnek, mint egy névtelen metódus amit ott hozunk létre, ahol éppen szükségünk van rá. Tegyük fel, hogy az egyik metódus egy függvényt kér harmadik paramétereként és ahelyett hogy írnál egy függvénnyt, amire csak egyszer lesz szükséged, megírhatod helyben, névtelenül és a kód továbbra is átlátható marad. Az alábbi példa ezt szemlélteti:
        </para>
        <programlisting><![CDATA[
              // function to count numbers greater than or equal to N
              // [=] denotes,   can access all variable
              int count_N = count_if(v1.begin(), v1.end(), [=](int a)
              {
                  return (a >= N);
              }); ]]>
        </programlisting>
        <para>
          A lambda kifejezések 3 fő részből állnak:
        </para>
        <programlisting><![CDATA[[ captures ] ( params ) { body } ]]>
        </programlisting>
        <para>
          A <function>[]</function> zárójelek között megadhatjuk a környezetéből azokat a változókat, amelyeket használni szeretnénk. Elérhetjük őket érték (<function>[=]</function>) vagy referencia (<function>[&amp;]</function>) alapján is. Például:
        </para>
        <programlisting><![CDATA[
[&total, factor]
[factor, &total]
[&, factor]
[factor, &]
[=, &total]
[&total, =]
          ]]>
        </programlisting>
        <para>
          A <function>()</function> zárójelek között definiáljuk a kis függvényünk paramétereit. Ez után jön a visszatérési érték megadása, amely nem kötelező.
        </para>
        <programlisting><![CDATA[[] () ->int { }]]>
        </programlisting>
        <para>
          A Robotautó Világbajnokságban a <function>sort()</function> függvény harmadik paramétereként megadtunk egy saját függvényt, amely a szerint fogja rendezni a gengsztereket, hogy azok milyen messze vannak a rendőrtől. Visszatérési értéket nem definiáltunk mert egyértelmű és ilyenkor nincs rá szükség, mert a fordító megállapítja a típust.
        </para>
        <programlisting language="c++"><![CDATA[std::sort( gangsters.begin(), gangsters.end(),
           [this, cop] ( unsigned x, unsigned y ) {
               return dst(cop, x) < dst(cop, y);
            } );]]>
        </programlisting>


    </section>

    <section>
        <title>C++11 Custom Allocator</title>
        <para>
          https://prezi.com/jvvbytkwgsxj/high-level-programming-languages-2-c11-allocators/ a
CustomAlloc-os példa, lásd C forrást az UDPROG repóban!
        </para>

        <para>

        </para>


    </section>

    <section>
        <title>STL map érték szerinti rendezése</title>
        <para>
          Például: https://github.com/nbatfai/future/blob/master/cs/F9F2/fenykard.cpp#L180
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="chomsky2/pasz_opengl/para6.cpp">
            <filename>bhax/thematic_tutorials/bhax_textbook/chomsky2/pasz_opengl/para6.cpp</filename>
            </link>
        </para>

        <para>

        </para>
        <programlisting><![CDATA[#include <GL/glut.h>]]>
        </programlisting>


    </section>

    <section>
        <title>Alternatív Tabella rendezése</title>
        <para>
          Mutassuk be a <link xlink:href="https://progpater.blog.hu/2011/03/11/alternativ_tabella">https://progpater.blog.hu/2011/03/11/alternativ_tabella</link> a programban a java.lang
Interface Comparable&lt;T&gt; szerepét!
        </para>
        <para>
          Javában az Interface-ek hasonlóan működnek, mint az osztályok, de az Interface-ekben sosem határozzuk meg a metódusok törzsét, így ez a feladat arra az osztályra hárul, amelyik implementálja azt. Implementálni az <function>implements</function> kulcsszóval lehet és az interface neve után kisebb-nagyobb opoerátorok között megadjuk az osztály nevét. C++-al ellentétben, Javában az osztályok egyszerre csupán 1 osztály leszármazottai lehetnek, de interface-ekből többet is implementálhatnak.
        </para>
        <programlisting><![CDATA[class Csapat implements Comparable<Csapat> {
          ...
}]]>
        </programlisting>
        <para>
          Miután definiáltuk a <function>Csapat</function> osztály mezőit és metódusait, megírjuk a <function>Comparable</function> interface általunk használni kívánt <function>compareTo()</function> függvényének törzsét. A visszatérési érték egy <function>int</function> típusú pozitív vagy negatív szám vagy nulla. Ha a függvényt meghívó objektum <function>ertek</function> valtozója kisebb, mint az argumentumban átadotté, akkor az eredmény -1 lesz, jelezve ezzel, hogy az értékünk kisebb mint akihez hasonlítottuk azt, 1 lesz ha nagyobb értékünk van és 0 ha megegyeznek.
        </para>
        <programlisting><![CDATA[class Csapat implements Comparable<Csapat> {

  protected String nev;
  protected double ertek;

  public Csapat(String nev, double ertek) {
    this.nev = nev;
    this.ertek = ertek;
  }

  public int compareTo(Csapat csapat) {
    if (this.ertek < csapat.ertek) {
      return -1;
    } else if (this.ertek > csapat.ertek) {
      return 1;
    } else {
      return 0;
    }
  }
}]]>
        </programlisting>


    </section>

    <section>
        <title>Prolog családfa</title>
        <para>
          Ágyazd be a Prolog családfa programot C++ vagy Java programba! Lásd para_prog_guide.pdf!
        </para>


    </section>


</chapter>
