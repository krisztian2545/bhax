<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gödel!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Gengszterek</title>
        <para>
          Gengszterek rendezése lambdával a Robotautó Világbajnokságban
https://youtu.be/DL6iQwPx1Yw (8:05-től)
        </para>
        <para>
          C++11-óta rendelkezésünkre áll az ún. lambda kifejezések létrehozására. Ezek úgy működnek, mint egy névtelen metódus amit ott hozunk létre, ahol éppen szükségünk van rá. Tegyük fel, hogy az egyik metódus egy függvényt kér harmadik paramétereként és ahelyett hogy írnál egy függvénnyt, amire csak egyszer lesz szükséged, megírhatod helyben, névtelenül és a kód továbbra is átlátható marad. Az alábbi példa ezt szemlélteti:
        </para>
        <programlisting><![CDATA[
              // function to count numbers greater than or equal to N
              // [=] denotes,   can access all variable
              int count_N = count_if(v1.begin(), v1.end(), [=](int a)
              {
                  return (a >= N);
              }); ]]>
        </programlisting>
        <para>
          A lambda kifejezések 3 fő részből állnak:
        </para>
        <programlisting><![CDATA[[ captures ] ( params ) { body } ]]>
        </programlisting>
        <para>
          A <function>[]</function> zárójelek között megadhatjuk a környezetéből azokat a változókat, amelyeket használni szeretnénk. Elérhetjük őket érték (<function>[=]</function>) vagy referencia (<function>[&amp;]</function>) alapján is. Például:
        </para>
        <programlisting><![CDATA[
[&total, factor]
[factor, &total]
[&, factor]
[factor, &]
[=, &total]
[&total, =]
          ]]>
        </programlisting>
        <para>
          A <function>()</function> zárójelek között definiáljuk a kis függvényünk paramétereit. Ez után jön a visszatérési érték megadása, amely nem kötelező.
        </para>
        <programlisting><![CDATA[[] () ->int { }]]>
        </programlisting>
        <para>
          A Robotautó Világbajnokságban a <function>sort()</function> függvény harmadik paramétereként megadtunk egy saját függvényt, amely a szerint fogja rendezni a gengsztereket, hogy azok milyen messze vannak a rendőrtől. Visszatérési értéket nem definiáltunk mert egyértelmű és ilyenkor nincs rá szükség, mert a fordító megállapítja a típust.
        </para>
        <programlisting language="c++"><![CDATA[std::sort( gangsters.begin(), gangsters.end(),
           [this, cop] ( unsigned x, unsigned y ) {
               return dst(cop, x) < dst(cop, y);
            } );]]>
        </programlisting>


    </section>

    <section>
        <title>C++11 Custom Allocator</title>
        <para>
          https://prezi.com/jvvbytkwgsxj/high-level-programming-languages-2-c11-allocators/ a
CustomAlloc-os példa, lásd C forrást az UDPROG repóban!
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="godel/my_allocator.c">
            <filename>bhax/thematic_tutorials/bhax_textbook/godel/my_allocator.c</filename>
            </link>
        </para>
        <para>
          A standard allokátor az <function>std::allocator&lt;T&gt;</function>, de mi most egy sajátot fogunk írni C-ben.
        </para>
        <para>
          A memóriafoglalást az <function>allocate(size)</function> függvény végzi. Attribútumként megkapja a tárolni kívánt elemek számát <function>size_t</function> típussal, amely az adatok méretét szokta tárolni (és a <function>sizeof()</function> függvény visszatérési értéke is ilyen típusú). Az <function>int s</function> és <function>char* p</function> változókat csupán szemléltetés végett léteznek, hogy kiírassuk az adattípust. A lényeg a <function>return</function> kulcsszó után van, ahol a <function>reinterpret_cast&lt;new_type&gt;(expression)</function> függvény jelen esetben <function>&lt;T*&gt;</function> típusúvá konvertálja amit átadunk neki. Mivel a <function>char</function> típus pontosan 1 bájtot foglal, így egy megfelelő méretű <function>char</function> típusú tömb pont annyi helyet fog foglalni, amennyire szükségünk van. Ezt úgy számoljuk ki, hogy a típus memóriaigényét megszorozzuk a darabszámmal.
        </para>
        <programlisting><![CDATA[
          using size_type = size_t;
          ...
          pointer allocate(size_type n){
            int s;
            char* p = abi::__cxa_demangle( typeid(T).name(), 0, 0, &s );
            std::cout << "Allocating "
                  << n << " objects of "
                  << n * sizeof(T)
                  << " bytes. "
                  << typeid(T).name() << "=" << p
                  << std::endl;
            free(p);
            return reinterpret_cast<T*>( new char[ n * sizeof(T) ] );
          }
          ]]>
        </programlisting>
        <para>
          A memória felszabadításához meghívjuk a <function>delete[]</function> kulcsszót és utána csinálunk egy kis nyomkövetést:
        </para>
        <programlisting><![CDATA[
          void deallocate(pointer p, size_type n){
            delete[] reinterpret_cast<char *>(p);
            std::cout << "Deallocating "
                  << n << " objects of "
                  << n * sizeof(T)
                  << " bytes. "
                  << typeid(T).name() << "=" << p
                  << std::endl;
          }
          ]]>
        </programlisting>
        <para>
          Szemléltetés végett a <function>main()</function> metódusban létrehoztunk egy <function>int</function> típusú vektort és átadtuk neki a saját allokátorunkat, hogy azt használja, valamint feltöltöttük a vektort számokkal 0-tól 14-ig, hogy lássuk, mi is történik. Egy <function>int</function> 4 bájton tárolható és láthatjuk, hogy amint meghaladjuk a lefoglalt memóriát, újra foglalunk, de már 2-szer annyit és a régit felszabadítjuk:
        </para>
        <programlisting><![CDATA[$ ./my_allocator
Allocating 1 objects of 4 bytes. i=int
0
Allocating 2 objects of 8 bytes. i=int
Deallocating 1 objects of 4 bytes. i=0x564ff17cbe70
1
Allocating 4 objects of 16 bytes. i=int
Deallocating 2 objects of 8 bytes. i=0x564ff17cc2a0
2
3
Allocating 8 objects of 32 bytes. i=int
Deallocating 4 objects of 16 bytes. i=0x564ff17cbe70
4
5
6
7
Allocating 16 objects of 64 bytes. i=int
Deallocating 8 objects of 32 bytes. i=0x564ff17cc2c0
8
9
10
11
12
13
14
Deallocating 16 objects of 64 bytes. i=0x564ff17cc2f0
]]>
        </programlisting>


    </section>

    <section>
        <title>STL map érték szerinti rendezése</title>
        <para>
          Például: https://github.com/nbatfai/future/blob/master/cs/F9F2/fenykard.cpp#L180
        </para>

        <para>

        </para>
        <programlisting><![CDATA[#include <GL/glut.h>]]>
        </programlisting>


    </section>

    <section>
        <title>Alternatív Tabella rendezése</title>
        <para>
          Mutassuk be a <link xlink:href="https://progpater.blog.hu/2011/03/11/alternativ_tabella">https://progpater.blog.hu/2011/03/11/alternativ_tabella</link> a programban a java.lang
Interface Comparable&lt;T&gt; szerepét!
        </para>
        <para>
          Javában az Interface-ek hasonlóan működnek, mint az osztályok, de az Interface-ekben sosem határozzuk meg a metódusok törzsét, így ez a feladat arra az osztályra hárul, amelyik implementálja azt. Implementálni az <function>implements</function> kulcsszóval lehet és az interface neve után kisebb-nagyobb opoerátorok között megadjuk az osztály nevét. C++-al ellentétben, Javában az osztályok egyszerre csupán 1 osztály leszármazottai lehetnek, de interface-ekből többet is implementálhatnak.
        </para>
        <programlisting><![CDATA[class Csapat implements Comparable<Csapat> {
          ...
}]]>
        </programlisting>
        <para>
          Miután definiáltuk a <function>Csapat</function> osztály mezőit és metódusait, megírjuk a <function>Comparable</function> interface általunk használni kívánt <function>compareTo()</function> függvényének törzsét. A visszatérési érték egy <function>int</function> típusú pozitív vagy negatív szám vagy nulla. Ha a függvényt meghívó objektum <function>ertek</function> valtozója kisebb, mint az argumentumban átadotté, akkor az eredmény -1 lesz, jelezve ezzel, hogy az értékünk kisebb mint akihez hasonlítottuk azt, 1 lesz ha nagyobb értékünk van és 0 ha megegyeznek.
        </para>
        <programlisting><![CDATA[class Csapat implements Comparable<Csapat> {

  protected String nev;
  protected double ertek;

  public Csapat(String nev, double ertek) {
    this.nev = nev;
    this.ertek = ertek;
  }

  public int compareTo(Csapat csapat) {
    if (this.ertek < csapat.ertek) {
      return -1;
    } else if (this.ertek > csapat.ertek) {
      return 1;
    } else {
      return 0;
    }
  }
}]]>
        </programlisting>


    </section>

    <section>
        <title>Prolog családfa</title>
        <para>
          Ágyazd be a Prolog családfa programot C++ vagy Java programba! Lásd para_prog_guide.pdf!
        </para>


    </section>


</chapter>
